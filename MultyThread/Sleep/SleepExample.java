package MultyThread.Sleep;

/**
 * Проблема:
 * Использование Thread.sleep для ожидания может быть неэффективным, так как поток блокируется на фиксированное время,
 * даже если задача может быть выполнена раньше. Это приводит к неэффективному использованию ресурсов и
 * увеличению времени отклика.
 * Thread.sleep не позволяет гибко управлять временем ожидания и не предоставляет возможности для обработки прерываний
 * или отмены задач.
 * Где может встречаться:
 * В приложениях, где требуется выполнение задач с задержкой, например, в системах планирования задач, таймерах или в
 * играх для реализации задержек между действиями.
 * В веб-серверах или сервисах, где необходимо ожидание между запросами или выполнение периодических задач.
 */
public class SleepExample {
    public static void main(String[] args) {
        Runnable task = () -> {
            System.out.println("Task started");
            try {
                Thread.sleep(5000); // Использование Thread.sleep для ожидания
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("Task completed");
        };

        Thread thread = new Thread(task);
        thread.start();
    }
}
